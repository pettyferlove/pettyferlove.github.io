<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.2.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="alternate" href="/atom.xml" title="箫声锁梦的博客" type="application/atom+xml"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css"><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Pisces",version:"7.5.0",exturl:!1,sidebar:{position:"left",display:"post",offset:12,onmobile:!1},copycode:{enable:!1,show_result:!1,style:null},back2top:{enable:!0,sidebar:!1,scrollpercent:!0},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!0,mediumzoom:!1,lazyload:!1,pangu:!1,algolia:{appID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},path:"search.xml",motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},translation:{copy_button:"复制",copy_success:"复制成功",copy_failure:"复制失败"},sidebarPadding:40}</script><meta name="description" content="个人技术分享，复盘，记录"><meta property="og:type" content="website"><meta property="og:title" content="箫声锁梦的博客"><meta property="og:url" content="http://blog.pettyfer.cn/page/2/index.html"><meta property="og:site_name" content="箫声锁梦的博客"><meta property="og:description" content="个人技术分享，复盘，记录"><meta property="og:locale" content="zh_CN"><meta property="article:author" content="箫声锁梦"><meta property="article:tag" content="Java,Vue,前端，后端，大数据"><meta name="twitter:card" content="summary"><link rel="canonical" href="http://blog.pettyfer.cn/page/2/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!0,isPost:!1,isPage:!1,isArchive:!1}</script><title>箫声锁梦的博客</title><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?adbf0f6727c4dc413bedb4b2ea553389";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-meta"><div><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">箫声锁梦的博客</span> <span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle">身自在，观其妙。</p></div><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-主页"><a href="/" rel="section"><i class="fa fa-fw fa-home"></i>主页</a></li><li class="menu-item menu-item-关于我"><a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于我</a></li><li class="menu-item menu-item-分类"><a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a></li><li class="menu-item menu-item-归档"><a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a></li><li class="menu-item menu-item-标签"><a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="site-search"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="搜索..." spellcheck="false" type="text" id="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"></div></div><div class="search-pop-overlay"></div></div></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content"><div class="posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://blog.pettyfer.cn/2019/08/08/linux/clamav-install/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="箫声锁梦"><meta itemprop="description" content="个人技术分享，复盘，记录"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="箫声锁梦的博客"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"><a href="/2019/08/08/linux/clamav-install/" class="post-title-link" itemprop="url">ClamAV反病毒软件安装与使用</a></h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2019-08-08 09:57:12" itemprop="dateCreated datePublished" datetime="2019-08-08T09:57:12+08:00">2019-08-08</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2022-03-07 16:33:30" itemprop="dateModified" datetime="2022-03-07T16:33:30+08:00">2022-03-07</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8/" itemprop="url" rel="index"><span itemprop="name">系统安全</span> </a></span></span><span id="/2019/08/08/linux/clamav-install/" class="post-meta-item leancloud_visitors" data-flag-title="ClamAV反病毒软件安装与使用" title="阅读次数"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span class="leancloud-visitors-count"></span></span></div></header><div class="post-body" itemprop="articleBody"><html><head></head><body></body></html><html><head></head><body><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;Linux服务器常用系统，以安全著称，不过随着市场占有量的增大，Linux病毒也存在病毒。而对于病毒，管理员手动分析进行查杀，除了手动分析查杀病毒外，还可以借助杀毒软件进行查杀，如同Windows都有杀毒软件一样，Linux系统发展至今也有不少优秀的反病毒软件，这里就不一一列举了。本文主要使用开源的<strong>ClamAV</strong>反病毒软件。</p><p>&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;<a target="_blank" rel="noopener" href="http://www.clamav.net/">ClamAV</a> 官网 <a target="_blank" rel="noopener" href="http://www.clamav.net/">http://www.clamav.net/</a></p><h1 id="安装以及使用"><a href="#安装以及使用" class="headerlink" title="安装以及使用"></a>安装以及使用</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 更新Epel仓库</span><br><span class="line">~$ yum -y install epel-releas</span><br><span class="line"></span><br><span class="line">// 安装ClamAV</span><br><span class="line">~$ yum install –y clamav clamav-update</span><br></pre></td></tr></tbody></table></figure><h2 id="更新病毒库"><a href="#更新病毒库" class="headerlink" title="更新病毒库"></a>更新病毒库</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~$ freshclam</span><br></pre></td></tr></tbody></table></figure><h2 id="开始扫描"><a href="#开始扫描" class="headerlink" title="开始扫描"></a>开始扫描</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">clamscan [选项] [路径] [文件]</span><br><span class="line"></span><br><span class="line">--quiet   使用安静模式，仅仅打印出错误信息</span><br><span class="line"></span><br><span class="line">-i  仅仅打印被感染的文件</span><br><span class="line"></span><br><span class="line">-d &lt;文件&gt; 以指定的文件作为病毒库，一代替默认的/var/clamav目录下的病毒库文件</span><br><span class="line"></span><br><span class="line">-l &lt;文件&gt; 指定日志文件，以代替默认的/var/log/clamav/freshclam.log文件</span><br><span class="line"></span><br><span class="line">-r 递归扫描，即扫描指定目录下的子目录</span><br><span class="line"></span><br><span class="line">--move=&lt;目录&gt; 把感染病毒的文件移动到指定目录</span><br><span class="line"></span><br><span class="line">--remove 删除感染病毒的文件</span><br><span class="line"></span><br><span class="line">--exclude=&lt;目录&gt; 需要排除的目录</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><blockquote><p>注意：如果扫描全盘可能会因为权限问题而打印很多警告信息，如果不是必要可以忽略/sys目录</p></blockquote><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 扫描/home并移除感染文件</span><br><span class="line">~$ clamscan --exclude=/sys/ -ri /home -l clamscan.log --remove</span><br><span class="line"></span><br><span class="line">----------- SCAN SUMMARY -----------</span><br><span class="line">Known viruses: 6260278</span><br><span class="line">Engine version: 0.101.2</span><br><span class="line">Scanned directories: 124</span><br><span class="line">Scanned files: 105</span><br><span class="line">Infected files: 0</span><br><span class="line">Data scanned: 12.73 MB</span><br><span class="line">Data read: 9.34 MB (ratio 1.36:1)</span><br><span class="line">Time: 42.754 sec (0 m 42 s)</span><br></pre></td></tr></tbody></table></figure><h2 id="设置定时任务"><a href="#设置定时任务" class="headerlink" title="设置定时任务"></a>设置定时任务</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">crontab -e</span><br><span class="line">1  4  * * *     /usr/local/clamav/bin/freshclam</span><br><span class="line">50 4  * * *     /usr/local/clamav/bin/clamscan -ri / -l /var/log/clamscan.log --move=/virus</span><br></pre></td></tr></tbody></table></figure></body></html></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://blog.pettyfer.cn/2019/08/07/java/jvm/jvm-memory-model/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="箫声锁梦"><meta itemprop="description" content="个人技术分享，复盘，记录"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="箫声锁梦的博客"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"><a href="/2019/08/07/java/jvm/jvm-memory-model/" class="post-title-link" itemprop="url">JVM 虚拟机内存模型</a></h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2019-08-07 13:43:11" itemprop="dateCreated datePublished" datetime="2019-08-07T13:43:11+08:00">2019-08-07</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2022-03-07 16:33:30" itemprop="dateModified" datetime="2022-03-07T16:33:30+08:00">2022-03-07</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span> </a></span>， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span> </a></span></span><span id="/2019/08/07/java/jvm/jvm-memory-model/" class="post-meta-item leancloud_visitors" data-flag-title="JVM 虚拟机内存模型" title="阅读次数"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span class="leancloud-visitors-count"></span></span></div></header><div class="post-body" itemprop="articleBody"><html><head></head><body></body></html><html><head></head><body><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文中部分内容引用至《深入理解Java虚拟机：JVM高级特性与最佳实践（第2版）》第12章，如果有兴趣可自行深入阅读，文末放有书籍PDF版本连接。</p><h1 id="一、物理机中的并发"><a href="#一、物理机中的并发" class="headerlink" title="一、物理机中的并发"></a>一、物理机中的并发</h1><blockquote><p>物理机遇到的并发问题其实与虚拟机中的情况有很多相似之处，所以物理机对并发的处理方案对于虚拟机的实现也有比较大的参考意义</p></blockquote><p>&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;“充分的利用计算机效能”和“让计算机并发运行多个任务”之间的关系，看上去是紧密相连的，但是实际上并没有想象中的那么简单，这其中有一个重要的原因在于计算机的大多数任务不能仅仅只依靠处理器去完成，处理器至少需要和内存打交道，比如读取数据、保存结果等，而这一过程中的I/O是无法避免的。由于计算机的存储设备与处理器的运算速度有几个数量级的差距，所以现代计算机系统都不得不加入一层读写速度尽可能接近处理器运算速度的高速缓存（Cache）来作为内存与处理器之间的缓冲：将运算需要使用到的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步回内存之中，这样处理器就无须等待缓慢的内存读写了。<br>&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;但是这样这种情况也带来了另一个问题，“缓存一致性（Cache Coherence）”。</p><h2 id="缓存一致性（重要概念）"><a href="#缓存一致性（重要概念）" class="headerlink" title="缓存一致性（重要概念）"></a>缓存一致性<code>（重要概念）</code></h2><p>​ 多处理器中，每一个处理器都拥有自己的高速缓存，同时又共享同一主内存，如下图所示</p><p><img src="/images/jvm/physical-machine-memory-model.png"></p><p>当多个处理器对同一块内存区域进行运算的时候，将可能导致各自的缓存数据不一致，如果发生这种情况，那同步回到主内存时以谁的缓存数据为准呢？为了解决一致性的问题，需要各个处理器访问缓存时都遵循一些协议，在读写时要根据协议来进行操作，这类协 议有MSI、MESI（Illinois Protocol）、MOSI、Synapse、Firefly及Dragon Protocol等。在本中将会多次提到的“内存模型”一词，可以理解为在特定的操作协议下，对特定的内存或高速缓存进行读写访问的过程抽象。不同架构的物理机器可以拥有不一样的内存模型，而Java虚拟机也有自己的内存模型，并且这里介绍的内存访问操作与硬件的缓存访问操作具有很高的可比性。</p><p>​ 除了增加高速缓存之外，为了使得处理器内部的运算单元能尽量被 充分利用，处理器可能会对输入代码进行乱序执行（Out-Of-Order Execution）优化，处理器会在计算之后将乱序执行的结果重组，保证该 结果与顺序执行的结果是一致的，但并不保证程序中各个语句计算的先 后顺序与输入代码中的顺序一致，因此，如果存在一个计算任务依赖另 外一个计算任务的中间结果，那么其顺序性并不能靠代码的先后顺序来 保证。与处理器的乱序执行优化类似，Java虚拟机的即时编译器中也有 类似的指令重排序（Instruction Reorder）优化。</p><h1 id="二、Java内存模型"><a href="#二、Java内存模型" class="headerlink" title="二、Java内存模型"></a>二、Java内存模型</h1><p>​ Java虚拟机规范中试图定义一种Java内存模型（Java Memory Model,JMM）来屏蔽掉各种硬件和操作系统的内存访问差异，以实现让 Java程序在各种平台下都能达到一致的内存访问效果。在此之前，主流程序语言（如C/C++等）直接使用物理硬件和操作系统的内存模型，因此，会由于不同平台上内存模型的差异，有可能导致程序在一套平台上 并发完全正常，而在另外一套平台上并发访问却经常出错，因此在某些场景就必须针对不同的平台来编写程序。</p><p>​ 定义Java内存模型并非一件容易的事情，这个模型必须定义得足够严谨，才能让Java的并发内存访问操作不会产生歧义；但是，也必须定义得足够宽松，使得虚拟机的实现有足够的自由空间去利用硬件的各种 特性（寄存器、高速缓存和指令集中某些特有的指令）来获取更好的执 行速度。经过长时间的验证和修补，在JDK 1.5（实现了JSR-133）发布后，Java内存模型已经成熟和完善起来了。</p><h2 id="1-主内存和工作内存"><a href="#1-主内存和工作内存" class="headerlink" title="1.主内存和工作内存"></a>1.主内存和工作内存</h2><p>​ Java内存模型主要是定义变量的访问规则，通俗的来讲就是Java虚拟机对变量的存、取操作的底层细节。这里所说的变量指的是静态变量、常量、构成数组的元素、实例字段，不包含局部变量和方法参数，两者在Java虚拟机中属于线程私有，不会存在线程安全问题。</p><p>​ Java虚拟机为了保持程序执行的高效率，在定义内存模型的同时并没有限制执行引擎使用处理器特定的寄存器或缓存来和主内存交互，也没有限制即时编译器对代码执行顺序进行调整。</p><p>​ Java内存模型规定了所有的变量都存储在主内存（Main Memory） 中（此处的主内存与介绍物理硬件时的主内存名字一样，两者也可以互相类比，但此处仅是虚拟机内存的一部分）。每条线程还有自己的工作内存（Working Memory，可与前面讲的处理器高速缓存类比），线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程 对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的变量。不同的线程之间也无法直接访问对方工作 内存中的变量，线程间变量值的传递均需要通过主内存来完成，线程、 主内存、工作内存三者的交互关系如下图所示。</p><p><img src="/images/jvm/jvm-memory-model.png"></p><p>注意： Java内存模型与内存结构不能混为一谈，内存结构是指Java堆、栈、方法区等</p><h2 id="2-JVM的内存操作"><a href="#2-JVM的内存操作" class="headerlink" title="2.JVM的内存操作"></a>2.JVM的内存操作</h2><p>​ Java内存模型定义了以下8种操作，虚拟机实现时需要保证以下操作均是原子的，不可再分的（double和long类型在32位和64位平台上有一定区别需要特别留意）</p><ol><li>lock（锁定）：作用于主内存的变量，它把一个变量标识为一条线程独占的状态。</li><li>unlock（解锁）：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。</li><li>read（读取）：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用。</li><li>load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。</li><li>use（使用）：作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节 码指令时将会执行这个操作。</li><li>assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节 码指令时执行这个操作。</li><li>store（存储）：作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的write操作使用。</li><li>write（写入）：作用于主内存的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中。</li></ol><p>​ 如果要把一个变量从主内存复制到工作内存，那就要顺序地执行 read和load操作，如果要把变量从工作内存同步回主内存，就要顺序地 执行store和write操作。注意，Java内存模型只要求上述两个操作必须按 顺序执行，而没有保证是连续执行。也就是说，read与load之间、store 与write之间是可插入其他指令的，如对主内存中的变量a、b进行访问 时，一种可能出现顺序是read a、read b、load b、load a。除此之外， Java内存模型还规定了在执行上述8种基本操作时必须满足如下规则：</p><ul><li>不允许read和load、store和write操作之一单独出现，即不允许一个变量从主内存读取了但工作内存不接受，或者从工作内存发起回写了但主内存不接受的情况出现。</li><li>不允许一个线程丢弃它的最近的assign操作，即变量在工作内存中改变了之后必须把该变化同步回主内存。</li><li>不允许一个线程无原因地（没有发生过任何assign操作）把数据从线程的工作内存同步回主内存中。</li><li>一个新的变量只能在主内存中“诞生”，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量，换句话说，就是对一个变 量实施use、store操作之前，必须先执行过了assign和load操作。</li><li>一个变量在同一个时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同 次数的unlock操作，变量才会被解锁。</li><li>如果对一个变量执行lock操作，那将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load或assign操作初始 化变量的值。</li><li>如果一个变量事先没有被lock操作锁定，那就不允许对它执行unlock操作，也不允许去unlock一个被其他线程锁定住的变量。</li><li>对一个变量执行unlock操作之前，必须先把此变量同步回主内存中（执行store、write操作）。</li></ul><h2 id="3-特殊的volatile类型"><a href="#3-特殊的volatile类型" class="headerlink" title="3.特殊的volatile类型"></a>3.特殊的volatile类型</h2><p>​ Java虚拟机为volatile类型定义了一些特有的规则，当一个变量定义为volatile之后，它将具备两种特性，第一是保证此变量对所有线程的可见性，这里的“可见性”是指当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。而普通变量不能做到这一点，普通变量的值在线程间传递均需要通过主内存来完成，例如，线程A修改一个普通变量的值，然后向主内存进行回写，另外一条 线程B在线程A回写完成了之后再从主内存进行读取操作，新变量值才会对线程B可见。</p><p>​ 同时volatile对于很多人而言存在很多误解，其中有很多人认为<code>volatile修饰的变量对内存是立即可见的所以自然而然的认为是线程安全的</code>，然而这个观点是存在一定问题的。volatile修饰的变量对所有线程可见，但是变量本身的修改操作并不是原子性操作，这就导致volatile变量在多线程情况下并不一定是线程安全的，请看一下例子</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VolatileTest</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">int</span> total;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">THREAD_COUNT</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">increase</span><span class="params">()</span> {</span><br><span class="line">        total++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">        total = <span class="number">0</span>;</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(THREAD_COUNT);</span><br><span class="line">        Thread[] threads = <span class="keyword">new</span> <span class="title class_">Thread</span>[THREAD_COUNT];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; THREAD_COUNT; i++) {</span><br><span class="line">            threads[i] = <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() {</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>; a &lt; <span class="number">100</span>; a++) {</span><br><span class="line">                        increase();</span><br><span class="line">                    }</span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                }</span><br><span class="line">            });</span><br><span class="line">            threads[i].start();</span><br><span class="line">        }</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        System.out.println(total);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>这段代码启动了10个线程，每个线程执行100次累加，那么预期的输出应该为1000，但是当你实际执行之后会发现每次输出的结果大多数是小于1000，且每次输出的结果都不一样。造成这个问题的原因出现在total++，利用javap可以查看关键部分字节码指令，如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public static void increase();</span><br><span class="line">   descriptor: ()V</span><br><span class="line">   flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">   Code:</span><br><span class="line">     stack=2, locals=0, args_size=0</span><br><span class="line">        0: getstatic     #2                  // Field total:I</span><br><span class="line">        3: iconst_1</span><br><span class="line">        4: iadd</span><br><span class="line">        5: putstatic     #2                  // Field total:I</span><br><span class="line">        8: return</span><br><span class="line">     LineNumberTable:</span><br><span class="line">       line 10: 0</span><br><span class="line">       line 11: 8</span><br></pre></td></tr></tbody></table></figure><p>volatile保证了getstatic操作获取的值是正确的，但是在执行iconst_1（栈指令，入栈），iadd过程中，其他线程有可能已经计算完毕并且将数据更新到主内存中，这样就导致当前线程所拥有的的数据变成了<code>过期数据</code>，而后putstatic操作则会将过期数据更新至主内存。当所有线程执行完毕后，total的值便会小于预期数。</p><p>​ 由于volatile变量只能保证可见性，所以在实际运用中还需要遵循以下规则：</p><ul><li>运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。</li><li>变量不需要与其他的状态变量共同参与不变约束。</li></ul><p>​ 不过在下面这种情况中，volatile变量就非常适合</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VolatileDemo</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">boolean</span> stop;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="keyword">while</span> (!stop) {</span><br><span class="line">            <span class="comment">// do something</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span>{</span><br><span class="line">        stop=<span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>由于volatile变量对所有线程保持可见性，当变量被赋值为true时，就会停止循环，而在赋值的过程中没有出现非原子性操作，所以这种方法是可靠并且安全的。</p><h2 id="4-long和double变量的特殊规则"><a href="#4-long和double变量的特殊规则" class="headerlink" title="4.long和double变量的特殊规则"></a>4.long和double变量的特殊规则</h2><p>​ Java内存模型要求lock、unlock、read、load、assign、use、store、 write这8个操作都具有原子性，但是对于64位的数据类型（long和 double），在模型中特别定义了一条相对宽松的规定：允许虚拟机将没有被volatile修饰的64位数据的读写操作划分为两次32位的操作来进行， 即允许虚拟机实现选择可以不保证64位数据类型的load、store、read和 write这4个操作的原子性，这点就是所谓的long和double的非原子性协定 （Nonatomic Treatment ofdouble and long Variables）。</p><p>​ 如果有多个线程共享一个并未声明为volatile的long或double类型的 变量，并且同时对它们进行读取和修改操作，那么某些线程可能会读取 到一个既非原值，也不是其他线程修改值的代表了“半个变量”的数值。</p><p>​ 不过这种读取到“半个变量”的情况非常罕见（在目前商用Java虚拟机中不会出现），因为Java内存模型虽然允许虚拟机不把long和double 变量的读写实现成原子操作，但允许虚拟机选择把这些操作实现为具有原子性的操作，而且还“强烈建议”虚拟机这样实现。在实际开发中，目前各种平台下的商用虚拟机几乎都选择把64位数据的读写操作作为原子操作来对待，因此我们在编写代码时一般不需要把用到的long和double 变量专门声明为volatile。</p><h2 id="5-原子性、可见性与有序性"><a href="#5-原子性、可见性与有序性" class="headerlink" title="5.原子性、可见性与有序性"></a>5.原子性、可见性与有序性</h2><p>Java内存模型围绕着并发过程中如何处理原子性、可见性和顺序性这三个特征来设计的。</p><h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>​ 由Java内存模型来直接保证的原子性变量操作包括read、load、assign、use、store和write，我们大致可以认为基本数据类型的访问读写是具备原子性的（例外就是long和double的非原子性协定，读者只要知道这件事情就可以了，无须太过在意这些几乎不会发生的例外情况）。</p><h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><p>​ 可见性是指当一个线程修改了共享变量的 值，其他线程能够立即得知这个修改。上文在讲解volatile变量的时候我们已详细讨论过这一点。Java内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方式来实现可见性的，无论是普通变量还是volatile变量都是如此，普通变量与volatile变量的区别是，volatile的特殊规则保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新。因此，可以说 volatile保证了多线程操作时变量的可见性，而普通变量则不能保证这一 点。</p><h3 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h3><p>​ Java内存模型的有序性在前面讲解volatile时 也详细地讨论过了，Java程序中天然的有序性可以总结为一句话：如果 在本线程内观察，所有的操作都是有序的；如果在一个线程中观察另一 个线程，所有的操作都是无序的。前半句是指“线程内表现为串行的语 义”（Within-Thread As-If-Serial Semantics），后半句是指“指令重排 序”现象和“工作内存与主内存同步延迟”现象。</p><h2 id="6-并发先行原则"><a href="#6-并发先行原则" class="headerlink" title="6.并发先行原则"></a>6.并发先行原则</h2><p>​ 如果Java内存模型中所有的有序性都仅仅靠volatile和synchronized来完成，那么有一些操作将会变得很烦琐，但是我们在编写Java并发代码 的时候并没有感觉到这一点，这是因为Java语言中有一个“先行发 生”（happens-before）的原则。这个原则非常重要，它是判断数据是否 存在竞争、线程是否安全的主要依据，依靠这个原则，我们可以通过几条规则一揽子地解决并发环境下两个操作之间是否可能存在冲突的所有问题。</p><p>​ 先行发生是Java内存模 型中定义的两项操作之间的偏序关系，如果说操作A先行发生于操作 B，其实就是说在发生操作B之前，操作A产生的影响能被操作B观察到，“影响”包括修改了内存中共享变量的值、发送了消息、调用了方法等。可通过以下伪代码理解：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以下操作在线程A中执行</span></span><br><span class="line">a=<span class="number">1</span>；</span><br><span class="line"><span class="comment">//以下操作在线程B中执行</span></span><br><span class="line">b=a；</span><br><span class="line"><span class="comment">//以下操作在线程C中执行</span></span><br><span class="line">a=<span class="number">2</span>；</span><br></pre></td></tr></tbody></table></figure><p>假设线程A中的操作”a=1”先行发生于线程B的操作”b=a”，那么可以 确定在线程B的操作执行后，变量b的值一定等于1，得出这个结论的依 据有两个：一是根据先行发生原则，”a=1”的结果可以被观察到；二是线 程C还没“登场”，线程A操作结束之后没有其他线程会修改变量a的值。 现在再来考虑线程C，我们依然保持线程A和线程B之间的先行发生关系，而线程C出现在线程A和线程B的操作之间，但是线程C与线程B没有先行发生关系，那b的值会是多少呢？答案是不确定！1和2都有可能，因为线程C对变量a的影响可能会被线程B观察到，也可能不会，这时候线程B就存在读取到过期数据的风险，不具备线程安全性。</p><p>​ 以下是Java内存模型与生俱来的<code>先行发生关系</code>：</p><ul><li>程序次序规则（Program Order Rule）：在一个线程内，按照程序代码顺序，书写在前面的操作先行发生于书写在后面的操作。准确地说， 应该是控制流顺序而不是程序代码顺序，因为要考虑分支、循环等结构。</li><li>管程锁定规则（Monitor Lock Rule）：一个unlock操作先行发生于后面对同一个锁的lock操作。这里必须强调的是同一个锁，而“后面”是 指时间上的先后顺序。</li><li>volatile变量规则（Volatile Variable Rule）：对一个volatile变量的写操作先行发生于后面对这个变量的读操作，这里的“后面”同样是指时间 上的先后顺序。</li><li>线程启动规则（Thread Start Rule）：Thread对象的start()方法先行 发生于此线程的每一个动作。</li><li>线程终止规则（Thread Termination Rule）：线程中的所有操作都先 行发生于对此线程的终止检测，我们可以通过Thread.join()方法结束、 Thread.isAlive()的返回值等手段检测到线程已经终止执行。</li><li>线程中断规则（Thread Interruption Rule）：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过 Thread.interrupted()方法检测到是否有中断发生。</li><li>对象终结规则（Finalizer Rule）：一个对象的初始化完成（构造函 数执行结束）先行发生于它的finalize()方法的开始。</li><li>传递性（Transitivity）：如果操作A先行发生于操作B，操作B先行发生于操作C，那就可以得出操作A先行发生于操作C的结论。</li></ul><h1 id="下载链接"><a href="#下载链接" class="headerlink" title="下载链接"></a>下载链接</h1><p>《深入理解Java虚拟机：JVM高级特性与最佳实践（第2版）》</p><p>链接：<a target="_blank" rel="noopener" href="https://pan.baidu.com/s/10-g7DxVx95TwgNJNF4_Y4A">https://pan.baidu.com/s/10-g7DxVx95TwgNJNF4_Y4A</a><br>提取码：gm27<br>复制这段内容后打开百度网盘手机App，操作更方便哦</p></body></html></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://blog.pettyfer.cn/2019/08/06/mysql/mysql-session-security/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="箫声锁梦"><meta itemprop="description" content="个人技术分享，复盘，记录"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="箫声锁梦的博客"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"><a href="/2019/08/06/mysql/mysql-session-security/" class="post-title-link" itemprop="url">MySQL会话控制限制登录次数</a></h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2019-08-06 17:57:12" itemprop="dateCreated datePublished" datetime="2019-08-06T17:57:12+08:00">2019-08-06</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2022-03-07 16:33:30" itemprop="dateModified" datetime="2022-03-07T16:33:30+08:00">2022-03-07</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8/" itemprop="url" rel="index"><span itemprop="name">系统安全</span> </a></span></span><span id="/2019/08/06/mysql/mysql-session-security/" class="post-meta-item leancloud_visitors" data-flag-title="MySQL会话控制限制登录次数" title="阅读次数"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span class="leancloud-visitors-count"></span></span></div></header><div class="post-body" itemprop="articleBody"><html><head></head><body></body></html><html><head></head><body><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;一般我们开发环境的MySQL是没有配置登录保护的，但仅限于开发环境，正式环境是不允许无限制登录，存在很大的风险。</p><p>&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;MySQL 5.7 以后提供了Connection-Control插件用来控制客户端在登录操作连续失败一定次数后的响应的延迟。该插件可有效的防止客户端暴力登录的风险(攻击)。该插件包含以下两个组件：</p><ul><li>connection_control：控制失败次数以及延迟时间</li><li>connection_control_failed_login_attempts：将登录失败的操作记录至information_schema表</li></ul><h1 id="插件安装"><a href="#插件安装" class="headerlink" title="插件安装"></a>插件安装</h1><h2 id="增加配置文件"><a href="#增加配置文件" class="headerlink" title="增加配置文件"></a>增加配置文件</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">~$ vi /etc/my.cnf</span><br><span class="line"></span><br><span class="line">// 添加以下配置</span><br><span class="line">[mysqld]</span><br><span class="line">plugin-load-add                                 = connection_control.so</span><br><span class="line">connection-control                              = FORCE</span><br><span class="line">connection-control-failed-login-attempts        = FORCE</span><br><span class="line">connection_control_min_connection_delay         = 1000</span><br><span class="line">connection_control_max_connection_delay         = 86400</span><br><span class="line">connection_control_failed_connections_threshold = 3</span><br></pre></td></tr></tbody></table></figure><h2 id="执行安装命令"><a href="#执行安装命令" class="headerlink" title="执行安装命令"></a>执行安装命令</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//使用root账户登录</span><br><span class="line">~$ mysql -u root -p</span><br><span class="line"></span><br><span class="line">mysql&gt; install plugin connection_control soname "connection_control.so";</span><br><span class="line">mysql&gt; install plugin connection_control_failed_login_attempts soname "connection_control.so";</span><br></pre></td></tr></tbody></table></figure><h2 id="验证插件安装状态"><a href="#验证插件安装状态" class="headerlink" title="验证插件安装状态"></a>验证插件安装状态</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select plugin_name, plugin_status from information_schema.plugins where plugin_name like 'connection%';</span><br><span class="line"></span><br><span class="line">+------------------------------------------+---------------+</span><br><span class="line">| plugin_name                              | plugin_status |</span><br><span class="line">+------------------------------------------+---------------+</span><br><span class="line">| CONNECTION_CONTROL                       | ACTIVE        |</span><br><span class="line">| CONNECTION_CONTROL_FAILED_LOGIN_ATTEMPTS | ACTIVE        |</span><br><span class="line">+------------------------------------------+---------------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h1 id="修改插件配置"><a href="#修改插件配置" class="headerlink" title="修改插件配置"></a>修改插件配置</h1><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">~$ vi /etc/my.cnf</span><br><span class="line"></span><br><span class="line">// 修改以下配置，并重启MySQL</span><br><span class="line">// 阻塞一分钟</span><br><span class="line">connection_control_min_connection_delay         = 60000</span><br><span class="line">connection_control_max_connection_delay         = 86400</span><br><span class="line">// 可错误五次</span><br><span class="line">connection_control_failed_connections_threshold = 5</span><br></pre></td></tr></tbody></table></figure><h2 id="查看修改后配置"><a href="#查看修改后配置" class="headerlink" title="查看修改后配置"></a>查看修改后配置</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">~$ mysql -u root -p;</span><br><span class="line"></span><br><span class="line">mysql&gt; show variables like 'connection_control%';</span><br><span class="line"></span><br><span class="line">+-------------------------------------------------+------------+</span><br><span class="line">| Variable_name                                   | Value      |</span><br><span class="line">+-------------------------------------------------+------------+</span><br><span class="line">| connection_control_failed_connections_threshold | 5          |</span><br><span class="line">| connection_control_max_connection_delay         | 86400      |</span><br><span class="line">| connection_control_min_connection_delay         | 60000      |</span><br><span class="line">+-------------------------------------------------+------------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>可以看到登录失败五次后再次尝试登录会阻塞<br><img src="/images/mysql/mysql-login.png"></p><h1 id="查看登录记录"><a href="#查看登录记录" class="headerlink" title="查看登录记录"></a>查看登录记录</h1><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; use information_schema;</span><br><span class="line"></span><br><span class="line">// 查看用户登录失败次数，当用户登录成功则删除记录</span><br><span class="line">mysql&gt; select * from connection_control_failed_login_attempts;</span><br><span class="line">// 连接控制的使用次数</span><br><span class="line">mysql&gt; show global status like 'connection_control_delay_generated';</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></body></html></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><nav class="pagination"><a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span></nav></div></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="post-toc-wrap sidebar-panel"></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="箫声锁梦" src="/images/avatar.jpg"><p class="site-author-name" itemprop="name">箫声锁梦</p><div class="site-description" itemprop="description">个人技术分享，复盘，记录</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives"><span class="site-state-item-count">13</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">15</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">24</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="feed-link motion-element"><a href="/atom.xml" rel="alternate"><i class="fa fa-rss"></i>RSS</a></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/pettyferlove" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;pettyferlove" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a> </span><span class="links-of-author-item"><a href="/pettyferlove@live.cn" title="电子邮箱 → pettyferlove@live.cn"><i class="fa fa-fw fa-envelope"></i>电子邮箱</a> </span><span class="links-of-author-item"><a href="https://weibo.com/dreamliuyang" title="微博 → https:&#x2F;&#x2F;weibo.com&#x2F;dreamliuyang" rel="noopener" target="_blank"><i class="fa fa-fw fa-weibo"></i>微博</a></span></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2022</span> <span class="with-love"><i class="fa fa-user"></i> </span><span class="author" itemprop="copyrightHolder">本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0 </a>许可协议。转载请注明出处！</span></div><div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v6.2.0</div><span class="post-meta-divider">|</span><div class="theme-info">主题 – <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.5.0</div><script>function leancloudSelector(e){return document.getElementById(e).querySelector(".leancloud-visitors-count")}if(CONFIG.page.isPost)function addCount(e){var t=document.querySelector(".leancloud_visitors"),o=t.getAttribute("id").trim(),n=t.getAttribute("data-flag-title").trim();e("get","/classes/Counter?where="+JSON.stringify({url:o})).then(e=>e.json()).then(({results:t})=>{if(t.length>0){var l=t[0];e("put","/classes/Counter/"+l.objectId,{time:{__op:"Increment",amount:1}}).then(e=>e.json()).then(()=>{leancloudSelector(o).innerText=l.time+1}).catch(e=>{console.log("Failed to save visitor count",e)})}else e("post","/classes/Counter",{title:n,url:o,time:1}).then(e=>e.json()).then(()=>{leancloudSelector(o).innerText=1}).catch(e=>{console.log("Failed to create",e)})}).catch(e=>{console.log("LeanCloud Counter Error",e)})}else function showTime(e){var t=[...document.querySelectorAll(".leancloud_visitors")].map(e=>e.getAttribute("id").trim());e("get","/classes/Counter?where="+JSON.stringify({url:{$in:t}})).then(e=>e.json()).then(({results:e})=>{if(0!==e.length){for(var o=0;o<e.length;o++){var n=e[o],l=n.url,r=n.time;leancloudSelector(l).innerText=r}for(o=0;o<t.length;o++){var s=leancloudSelector(l=t[o]);""==s.innerText&&(s.innerText=0)}}else document.querySelectorAll(".leancloud_visitors .leancloud-visitors-count").forEach(e=>{e.innerText=0})}).catch(e=>{console.log("LeanCloud Counter Error",e)})}fetch("https://app-router.leancloud.cn/2/route?appId=x3Ivc0zREXPkMApVy0SznGKN-gzGzoHsz").then(e=>e.json()).then(({api_server:e})=>{var t=(t,o,n)=>fetch(`https://${e}/1.1${o}`,{method:t,headers:{"X-LC-Id":"x3Ivc0zREXPkMApVy0SznGKN-gzGzoHsz","X-LC-Key":"YymsXp9WQvoBI4pNToSbnYpl","Content-Type":"application/json"},body:JSON.stringify(n)});if(CONFIG.page.isPost){if(/http:\/\/(localhost|127.0.0.1|0.0.0.0)/.test(document.URL))return;addCount(t)}else document.querySelectorAll(".post-title-link").length>=1&&showTime(t)})</script></div></footer></div><script color="0,0,255" opacity="0.5" zindex="-1" count="99" src="/lib/canvas-nest/canvas-nest.min.js"></script><script src="/lib/anime.min.js"></script><script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script><script src="/js/local-search.js"></script></body></html>